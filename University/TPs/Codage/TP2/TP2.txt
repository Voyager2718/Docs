YANG Zhipeng

Question 1
print("%x,%o,%X"%(999,999,999))
>>>3e7,1747,3E7

bin(999)
>>>'0b1111100111'

oct(999)
>>>'0o1747'

hex(999)
>>>'0x3e7'

Question 2
"{:b}".format(1331)
>>>'10100110011'

"{:o}".format(1331)
>>>'2463'

"{:x}".format(1331)
>>>'533'

Question 3
n=0,chr(ord('0')+n)=0
n=1,chr(ord('0')+n)=1
n=2,chr(ord('0')+n)=2
n=3,chr(ord('0')+n)=3
n=4,chr(ord('0')+n)=4
n=5,chr(ord('0')+n)=5
n=6,chr(ord('0')+n)=6
n=7,chr(ord('0')+n)=7
n=8,chr(ord('0')+n)=8
n=9,chr(ord('0')+n)=9
n=10,chr(ord('0')+n)=:
n=11,chr(ord('0')+n)=;
n=12,chr(ord('0')+n)=<
n=13,chr(ord('0')+n)==
n=14,chr(ord('0')+n)=>
n=15,chr(ord('0')+n)=?
n=16,chr(ord('0')+n)=@
n=17,chr(ord('0')+n)=A
n=18,chr(ord('0')+n)=B
n=19,chr(ord('0')+n)=C

Question 4
def integer_to_digit(n):
    return chr(n+55)

Question 5
def integer_to_digit(n):
    assert(n>=0 and n<=15)
    if(n>=10):
            return chr(n+55)
    return chr(n+48)
	 
Question 6
def ent_chn(n,b):
    assert b != 1 and b <= 16
    if (n == 0):
            return ""
    ord = n % b
    c = integer_to_digit(ord)
    return integer_to_string(n//b, b) + c

def integer_to_string(n,b):
    if(ent_chn(n,b)==""):
            return ""
    return ent_chn(n,b)
  
Question 7
def print():
    for i in range(0,21):
            builtins.print("{:3d} :{:5s} {:5s} {:5s}".format(i,integer_to_string(i,2),integer_to_string(i,8),integer_to_string(i,16)))

Question 8
(i opérateurs logiques 4)
(e.g. i & 4 ou ^i)

i & | ^ ~ << >>
0 0 4 4 -1 0 0
1 0 5 5 -2 16 0
2 0 6 6 -3 32 0
3 0 7 7 -4 48 0

Question 9
<< n ça veut dire dégaler à gauche n bits.
>> n ça veut dire dégaler à droite n bits.

Question 10
def deux_puissance(n):
    assert n >= 0
    return 2 << n-1

Question 11
def pair(n):
    return n&1==0

Question 12
def integer_to_binary_str(n):
    if(n==0):
        return "0"
    return n_b(n)
	
def n_b(n,str=""):
    if(n==0):
        return ""
    if(pair(n)):
        return n_b(n>>1,str)+str+"0"
    return n_b(n>>1,str)+str+"1"

Question 13
def binary_str_to_integer (str,n=0,depth=0):
    if(str==""):
            return 0
    if(str[-1]=="0"):
            return n+binary_str_to_integer(str[0:-1],n,depth+1)
    if(str[-1]=="1"):
            return pow(2,depth)+binary_str_to_integer(str[0:-1],n,depth+1)

Question 14
def byte_to_binary(n):
    return "".join(str(1 & int(n) >> i) for i in range(8)[::-1])

Question 15
import struct
def float_to_bin(n):
    bytes_stored=struct.pack('>f',n)
    s=""
    for i in bytes_stored:
        s+=byte_to_binary(i)
    return s

Question 16
def change_a_bit(binary,position):
    if(binary[position]=="0"):
        return binary[0:position]+"1"+binary[position+1:]
    else:
        return binary[0:position]+"0"+binary[position+1:]

Question 17
def binary_to_bytes(str):
    return [binary_str_to_integer(str[0:8]),binary_str_to_integer(str[8:16]),binary_str_to_integer(str[16:])]

Question 18
def change_a_bit_in_float(float,position):
    f = float_to_bin(float)
    f = change_a_bit(f,position)
    return binary_to_bytes(f)

Question 19


Question 20
